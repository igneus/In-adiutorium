#!/bin/env ruby

# a small library + commandline utility to handle psalm tones
# written down in a custom yaml-based format
# and convert them to lilypond

require 'delegate'
require 'yaml'

class PsalmTone

  def initialize(data, name)
    @data = data
    @name = name
  end

  attr_reader :name

  %w(inchoatio tenor flexa mediatio terminatio).each do |i|
    define_method i do
      raise "key #{i.inspect} not defined in tone #{name.inspect}" unless @data.key? i

      @data[i]
    end
  end

  def differentiae
    terminatio.is_a?(Hash) ? terminatio.size : 1
  end

  # gets a copy of self with just one termination variant
  def get(differentia=nil)
    if differentiae == 1 then
      return self
    else
      single_data = @data.merge(
        'terminatio' => {differentia => terminatio[differentia].dup}
      )
      return self.class.new(single_data, @name)
    end
  end

  def all
    if differentiae == 1 then
      return [self]
    else
      return terminatio.collect do |t|
        code, music = t
        get(code)
      end
    end
  end

  def to_lilypond
    if differentiae > 1 then
      raise "This tone has #{differentiae} differentia. Use #get to reduce it to one, then call #to_lilypond..."
    end

    inch = lilify inchoatio, false
    flex = lilify flexa
    med = lilify mediatio
    if terminatio.is_a?(Hash) then
      term = lilify(terminatio.values.first)
      diff = terminatio.keys.first
    else
      term = lilify(terminatio)
      diff = ''
    end

    # leading underscores are used as a trick to allow having different
    # transposition under a single tone name (II.D and II.A and similar)
    clean_name = @name.sub(/^_+/, '')

    score_id = [clean_name.gsub(' ', ''), diff].select {|p| p != '' }.join('-')

    return "\\score{
  \\relative #{octave} {
    \\choralniRezim
    #{inch}
    #{flex} \\barMin
    #{med} \\barMaior
    #{term} \\barFinalis
  }
  \\header {
    modus = \"#{clean_name}\"
    differentia = \"#{diff}\"
    id = \"#{score_id}\"
    piece = \\markup\\sestavTitulekBezZalmu
  }
}"
  end

  def ==(t2)
    self.class == t2.class and
      inchoatio == t2.inchoatio and
      tenor == t2.tenor and
      flexa == t2.flexa and
      mediatio == t2.mediatio and
      terminatio == t2.terminatio
  end

  def lilify(part, recitanda=true)
    r = ''
    if recitanda then
      r += ((tenor.is_a?(Array) ? tenor.first : tenor) + ' ') * 2
    end
    r += part

    r.gsub!(/(\w{2,100})(-?)/) do 
      notes_raw = $1
      accent_mark = $2
      notes = $1.split('')
      notes[0] += '('
      if accent_mark.start_with? '-' then
        notes[0] += '-!'
      end
      notes[-1] += ')'
      notes.join(' ')
    end
    r.gsub!('b', 'bes')
    r.gsub!('h', 'b')
    r.gsub!(/((\w{1})-)/) { $2+'-!' }
    r.gsub!(/(\{(\w{1})\})/) { '\parenthesize ' + $2}

    r.insert((r.index(/[^\w]/) or -1), '4') # add duration to the very first note

    return r
  end

  def octave
    octave = "c'"

    # this is quite dirty and not at all universal ...
    if ['_II', 'III', 'IV', 'IV alt', 'VII', 'VIII', 'per'].include? @name then
      octave = "c''"
    end

    return octave
  end
end

class PsalmToneGroup < SimpleDelegator

  def initialize(data)
    @tones = {}
    super(@tones)
    data.each_pair do |key, val|
      @tones[key] = PsalmTone.new val, key
    end
  end

  class << self
    def from_yaml(str)
      new(YAML.load(str))
    end

    def from_file(fname)
      from_yaml(File.read(fname))
    end
  end
end

if $0 == __FILE__ then

  inf = ARGV.shift
  #outf = File.basename(inf).delete('.yml')+'.ly'
  #File.open(outf, 'w') do |fw|
  fw = STDOUT

  fw.puts "% generated by psalmtone.rb from #{inf}\n"
  fw.puts "\\version \"2.19.4\"\n"
  fw.puts "\\include \"spolecne.ly\"\n\n"
  fw.puts <<EOS
\\paper {
  scoreTitleMarkup = \\markup\\concat {
    \\fromproperty #'header:modus . \\fromproperty #'header:differentia
  }
}
EOS
  PsalmToneGroup.from_file(inf).each_pair do |name,tone|
    tone.all.each {|t| fw.puts t.to_lilypond }
    puts
  end
  #end
end
